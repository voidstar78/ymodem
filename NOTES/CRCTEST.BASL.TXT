REM XIPHOD - DEC 2025

REM https://crccalc.com/?crc=A&method=&datatype=ascii&outtype=hex
REM https://crccalc.com/?crc=A&method=CRC-16/XMODEM&datatype=ascii&outtype=hex
REM https://www.sunshine2k.de/coding/javascript/crc/crc_js.html
REM http://www.ciphersbyritter.com/ARTS/CRCMYST.HTM

MAGIC.VALUE% = $1021
REM THESE ONLY WORK WHEN X <= 32767 AND X >= -32768 (SPECIFICALLY THE "OR" AND "AND" KEYWORDS)
REM X XOR Y = (X OR Y) AND NOT (X AND Y)
REM ALTERNATIVE:  (X+Y) - 2*(X AND Y)
DEF FN XM(X) = (X + XV) - 2*(X AND XV)

DIM CRC.DATA%(1024) : REM CRC.DATA%(0) CONTAINS LENGTH

GOSUB INIT.CRC.DATA

GOSUB CALC.CRC

GOSUB PRINT.CRC.AS.HEX

END

REM INTERNAL EXAMPLE OF RECEIVING SOME DATA THAT WE WANT TO
REM THEN MAINTAIN A CRC OF.  THIS "SIMULATES" A FILE LOAD OR
REM SERIAL DATA RECEIVE.
INIT.CRC.DATA:
  I% = 0
INIT.CRC.NEXT:  
  READ A% : REM SIGNED 16-BIT
  IF A% < 0 THEN CRC.DATA%(0) = I% : RETURN
  I% = I% + 1 : CRC.DATA%(I%) = A%
  GOTO INIT.CRC.NEXT  

CALC.CRC:
  CRC.RESULT = $0 : REM INITIAL VALUE  (XMODEM INIT 0, FOR IBM 3740 - START WITH $FFFF)  
  DATA.IDX% = 1 : REM DATA STARTS AT INDEX 1

NEXT.BYTE:
  IF DATA.IDX% > CRC.DATA%(0) THEN RETURN : REM CRC.RESULT COMPUTED
  
  REM CHR$ $80 ENABLES A "DON'T INTERPRET" SIGNAL, SO PETSCII SYMBOL
  REM OF SUBSEQUENT OUTPUT IS SHOWN INSTEAD OF CRT-EFFECT APPLIED.
  PRINT CHR$($80);CHR$(CRC.DATA%(DATA.IDX%));"(";CRC.DATA%(DATA.IDX%);") ";CRC.RESULT;" ";
  
  XV = CRC.DATA%(DATA.IDX%) * 256 : REM (CRC.DATA AT CURRENT INDEX) << 8
  REM THE FOLLOWING IS NECESSARY SO WE CAN USE "XV" LATER IN THE DO.XOR SUBROUTINE
  IF XV > 32767 THEN XV = XV - 65536
  IF XV < -32768 THEN XV = XV + 65536  
  
  CRC.TEMP = CRC.RESULT  
  CRC.TEMP = FN XM(CRC.TEMP) : REM XOR'D WITH XV  
  CRC.RESULT = CRC.TEMP
  GOSUB PRINT.CRC.AS.HEX : PRINT : REM PRINT HEX$(CRC.RESULT)  
  
  XV = MAGIC.VALUE% : REM PREPARE THAT WE WILL XOR BY THE XMODEM POLYNOMIAL
  FOR I = 0 TO 7    

    REM CAN'T USE "AND" RELIABLY ON SIGNED 16-BIT, BUT WE JUST NEED
    REM TO CHECK IF THE HIGH BIT (MSB) IS SET.  SO JUST LOOK AT THE HIGH-BYTE
    REM BY DIVIDING THE VALUE BY 256 (SAME AS SHR >> 8).
    CRC.LOW% = CRC.RESULT / 256
    IF CRC.LOW% AND $80 THEN GOTO HANDLE.HIGH.BIT.CASE

    REM ELSE...
    CRC.RESULT = CRC.RESULT * 2 : REM (CRC << 1)
HIGH.BIT.WAS.SET:
    IF CRC.RESULT > 32767 THEN CRC.RESULT = CRC.RESULT - 65536
    IF CRC.RESULT < -32768 THEN CRC.RESULT = CRC.RESULT + 65536
    PRINT "  ";I;" ";:GOSUB PRINT.CRC.AS.HEX : PRINT : REM PRINT HEX$(CRC.RESULT)
  NEXT
  
  DATA.IDX% = DATA.IDX% + 1
  GOTO NEXT.BYTE
  
HANDLE.HIGH.BIT.CASE:
  CRC.TEMP = CRC.RESULT * 2 : REM (CRC << 1)
  IF CRC.TEMP > 32767 THEN CRC.TEMP = CRC.TEMP - 65536
  IF CRC.TEMP < -32768 THEN CRC.TEMP = CRC.TEMP + 65536  
  CRC.TEMP = FN XM(CRC.TEMP) : REM XOR'D WITH XV  
  CRC.RESULT = CRC.TEMP  
  GOTO HIGH.BIT.WAS.SET : REM RESUME PAST THE IF-ELSE THAT WE CAME FROM

REM PRINT HEX$(CRC.RESULT)  
PRINT.CRC.AS.HEX:
  TEMP = CRC.RESULT : IF TEMP < 0 THEN TEMP = TEMP + 65536
  PRINT HEX$(TEMP);"(";CRC.RESULT;")";
  RETURN  

REM EXAMPLE DATA TO CRC, DECIMAL ASCII VALUES (A=65, ETC.)
DATA $01, $02, $04, $05, $07, $0B, $0C, $0E, $0F, $11, $12, $16, $17, $18, $19, $31 
DATA $32, $33, $34, $35, $36, $37, $38, $39, $30, $20, $01, $01, $01, $01, $01, $01
DATA $19, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
DATA $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
DATA $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
DATA $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
DATA $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
DATA $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
DATA -1
